<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// number of robots - n, threshold distance - t
const int n = 2;
const int t = 5;

// clock - cl, broadcasting channel - bc
clock cl;
broadcast chan bc;

// x coordinates - X, y coordinates - Y
int X[n];
int Y[n];

// number of neighbours - N, mutual distance to neighbours - D
int N[n];
double D[n][n];

int x_direction(int direction){
    // maps direction to x axis
    if (direction == 1){
        // right
        return 1;
    }
    if (direction == 3){
        // left
        return -1;
    }
    // neither
    return 0;
}

int y_direction(int direction){
    // maps direction to y axis
    if (direction == 0){
        // up
        return 1;
    }
    if (direction == 2){
        // down
        return -1;
    }
    // neither
    return 0;
}

int reverse(int direction){
    // reverses direction
    return direction * -1;
}

double distance(int x_1, int y_1, int x_2, int y_2){
    // calculates Euclidean distance between points 1 &amp; 2
    int x = abs(x_1 - x_2);
    int y = abs(y_1 - y_2);
    return sqrt(x*x + y*y);
} 

void update_distances(){
    // updates the array that stores distances between robots
    int i, j;
    for (i = 0; i &lt; n; i++){
        for (j = 0; j &lt; n; j++){
            if(i == j){
                D[i][j] = 1000;
            } else {
                D[i][j] = distance(X[i], Y[i], X[j], Y[j]);
            }
            
        }
    }
}

bool connected(double d){
    // returns true if distance between points 1 &amp; 2 is lower or equal to threshold t
    return d &lt;= t*1.0;
}

int neighbours(int id){
    // returns number of connections for robot with given id
    int x_1 = X[id];
    int y_1 = Y[id];
    int k = 0;
    int i = 0;
    for (i = 0; i &lt; n; i++){
        double d = distance(x_1, y_1, X[i], Y[i]);
        bool c = connected(d);
        // is robot connected to another robot
        if(i != id &amp;&amp; c){
            // increment neighbour counter
            k++;
        }
    }
    return k;
}

void update_neighbours(){
    // updates the array that stores number of neighbours for each robot
    int i;
    for (i = 0; i &lt; n; i++){
        N[i] = neighbours(i);
    }
}</declaration>
	<template>
		<name x="5" y="5">Robot</name>
		<parameter>int id, int x, int y, int x_dir, int y_dir, int k, int last_k, int alpha</parameter>
		<declaration>// Place local declarations here.
</declaration>
		<location id="id0" x="-731" y="-110">
			<name x="-816" y="-119">initial</name>
		</location>
		<location id="id1" x="-246" y="-348">
			<name x="-256" y="-382">turn_random</name>
		</location>
		<location id="id2" x="-238" y="255">
			<name x="-323" y="247">turn_180</name>
		</location>
		<location id="id3" x="374" y="-42">
			<name x="391" y="-68">forward</name>
		</location>
		<init ref="id0"/>
		<transition id="id4">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="guard" x="544" y="-76">alpha &lt;= N[id] &amp;&amp; N[id] &lt;= last_k</label>
			<label kind="assignment" x="552" y="-34">x += x_dir,
y += y_dir,
X[id] = x,
Y[id] = y,
last_k = N[id],
update_neighbours(),
update_distances()</label>
			<nail x="756" y="-42"/>
			<nail x="756" y="255"/>
			<nail x="501" y="255"/>
		</transition>
		<transition id="id5">
			<source ref="id3"/>
			<target ref="id1"/>
			<label kind="select" x="-76" y="-136">direction : int[0, 3]</label>
			<label kind="guard" x="-76" y="-161">N[id] &gt; last_k</label>
			<label kind="assignment" x="-76" y="-102">x_dir = x_direction(direction),
y_dir = y_direction(direction)</label>
			<nail x="272" y="-110"/>
			<nail x="-246" y="-110"/>
		</transition>
		<transition id="id6">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="assignment" x="-76" y="25">x += x_dir,
y += y_dir,
X[id] = x,
Y[id] = y,
last_k = N[id],
update_neighbours(),
update_distances()</label>
			<nail x="-238" y="17"/>
			<nail x="272" y="17"/>
		</transition>
		<transition id="id7">
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="guard" x="-76" y="229">N[id] &lt; last_k &amp;&amp; N[id] &lt; alpha</label>
			<label kind="assignment" x="-76" y="263">x_dir = reverse(x_dir),
y_dir = reverse(y_dir)</label>
			<nail x="374" y="255"/>
		</transition>
		<transition id="id8">
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="assignment" x="-68" y="-340">x += x_dir,
y += y_dir,
X[id] = x,
Y[id] = y,
last_k = N[id],
update_neighbours(),
update_distances()</label>
			<nail x="374" y="-348"/>
		</transition>
		<transition id="id9">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="select" x="-697" y="-382">direction : int[0, 3]</label>
			<label kind="assignment" x="-697" y="-340">x_dir = x_direction(direction),
y_dir = y_direction(direction),
update_neighbours(),
update_distances(),
last_k = N[id]</label>
			<nail x="-731" y="-348"/>
		</transition>
	</template>
	<template>
		<name>Clock</name>
		<parameter>int loop_counter</parameter>
		<location id="id10" x="0" y="0">
			<name x="-59" y="-8">loop</name>
			<label kind="invariant" x="-34" y="25">cl &lt;= 1</label>
		</location>
		<init ref="id10"/>
		<transition id="id11">
			<source ref="id10"/>
			<target ref="id10"/>
			<label kind="guard" x="136" y="-59">cl &gt;= 1 &amp;&amp;
loop_counter &lt; 100</label>
			<label kind="synchronisation" x="136" y="-8">bc!</label>
			<label kind="assignment" x="136" y="25">cl := 0,
loop_counter += 1</label>
			<nail x="102" y="-93"/>
			<nail x="102" y="-93"/>
			<nail x="102" y="93"/>
		</transition>
	</template>
	<system>// Place template instantiations here.
// int id, int x, int y, int x_dir, int y_dir, int threshold, int k, int last_k, int alpha
P1 = Robot(0, 0, 0, 0, 0, 0, 0, 1);
P2 = Robot(1, 0, 0, 0, 0, 0, 0, 1);

// C = Clock(0);
// List one or more processes to be composed into a system.
system P1, P2;
</system>
	<queries>
		<option key="--diagnostic" value="1"/>
		<query>
			<formula>A[] C.loop_counter == 50 imply (P1.final &amp;&amp; P2.final) || (P1.y_dir == P2.y_dir) || (P1.x_dir == P2.x_dir)</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-04-24 16:06:21 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A[] C.loop_counter &gt; 7 imply (P1.conn &amp;&amp; P2.conn) || (P1.final &amp;&amp; P2.final)</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-04-24 16:06:23 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A[] C.loop_counter &gt; 7 imply (P1.final &amp;&amp; P2.final) || (P1.y_dir == P2.y_dir) || (P1.x_dir == P2.x_dir)</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-04-10 12:39:23 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A&lt;&gt; (P1.conn &amp;&amp; P2.conn) || (P1.final &amp;&amp; P2.final)</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-04-24 16:37:41 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A[] (P1.conn &amp;&amp; P2.conn) || (P1.final &amp;&amp; P2.final)</formula>
			<comment/>
			<result outcome="failure" type="quality" timestamp="2024-04-24 16:37:36 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A[] C.loop_counter &gt; 7 imply (P1.conn &amp;&amp; P2.conn) || (P1.final &amp;&amp; P2.final)</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-04-24 16:37:20 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; P2.final</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-04-09 15:11:12 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; P1.final &amp;&amp; P2.final</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-04-09 15:11:15 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; (P1.final &amp;&amp; P2.final) imply connected(2)</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-04-09 15:03:46 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A[] not deadlock</formula>
			<comment/>
		</query>
	</queries>
</nta>
