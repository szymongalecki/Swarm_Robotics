<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.

// Number of robots - R, Beta parameter - BETA, Signal threshold - T, Grid boundary - G =&gt; Grid : 2G x 2G
const int R = 3;
const int T = 1;
const int BETA = 1;
const int G = 3;

// Robot coordinates
int x[R];
int y[R];

// Robot directions
int x_dir[R];
int y_dir[R];

// List of current and old neighbours lists for each robot
// Convention: 
//    - id of the robot will point to its neighbours list
//    - 1 at position id indicates connection with robot of a given id, 0 otherwise
int neighbours[R][R];
int old_neighbours[R][R];
int lost_neighbours[R][R];
int n_shared_neighbours[R];
int distances[R][R];

// Number of connections and old connections for each robot
int k[R];
int old_k[R];

// Map one of four directionos into x_dir and y_dir
void mapDirection(int id, int dir){
    if (dir == 0){
		// up
        x_dir[id] = 0;
        y_dir[id] = 1;
    }
    if (dir == 1){
		// right
        x_dir[id] = 1;
        y_dir[id] = 0;
    }
    if (dir == 2){
		// down
        x_dir[id] = 0;
        y_dir[id] = -1;
    }
    if (dir == 3){
		// left
        x_dir[id] = -1;
        y_dir[id] = 0;
    }
}

// Reverse current direction of the robot
void reverseDirection(int id){
	x_dir[id] *= -1;
	y_dir[id] *= -1;
}

// Move robot forward in its current direction
void moveForward(int id){
	x[id] += x_dir[id];
	y[id] += y_dir[id];
}

// Checks if robot is on the boundary of the grid
bool gridBoundary(int id){
    return abs(x[id]) == G || abs(y[id]) == G;
}

// Updates k and old_k
void updateConnections(int id){
   int i;
   int n;
   old_k[id] = k[id];
   for (i = 0; i &lt; R; i++){
       if (neighbours[id][i] == 1){
           n++;
       }
   }
   k[id] = n;
}

// Decide if robot should make a random turn
bool turnRandom(int id){
    return k[id] &gt; old_k[id];
}


// Decide if robot should turn around
bool turn180(int id){
    return n_shared_neighbours[id] &lt;= BETA;
}

// Calculates Euclidean distance between robots
double distance(int x1, int y1, int x2, int y2){
    return sqrt(pow(abs(x1 - x2), 2) + pow(abs(y1 - y2), 2));
}

// Checks if distance between robots is within a signal threshold
bool connected(double distance, double threshold){
    return distance &lt;= threshold;
}

// Update distances
void updateDistances(){
    int i;
    int j;
    for (i = 0; i &lt; R; i++){
        for (j = 0; j &lt; R; j++){
            distances[i][j] = fint(distance(x[i], y[i], x[j], y[j]));
        }
    }
}

// Updates lost_neighbours
void lostNeighbours(int id){
    int i;
    for (i = 0; i &lt; R; i++){
        if (old_neighbours[id][i] == 1 &amp;&amp; neighbours[id][i] == 0){
            lost_neighbours[id][i] = 1;
        } else {
            lost_neighbours[id][i] = 0;
        }
    }
}


// Returns the number of neighbours shared between two robots
int sharedNeighbours(int id1, int id2){
    int shared;
    int i;
    for (i = 0; i &lt; R; i++){
        if(neighbours[id1][i] == neighbours[id2][i] &amp;&amp; neighbours[id1][i] == 1){
            shared++;
        }
    }
    return shared;
}

// Updates n_shared_neighbours
void nSharedNeighbours(int id){
    int i;
    int n_shared;
    for (i = 0; i &lt; R; i++){
        if (old_neighbours[id][i] == 1 &amp;&amp; neighbours[id][i] == 0){
            n_shared += sharedNeighbours(id, i);
        }
    }
    n_shared_neighbours[id] = n_shared;
}

void updateNeighbours(int id){
    int i;
    old_neighbours[id] = neighbours[id];
    for (i = 0; i &lt; R; i++){
            if (connected(distance(x[id], y[id], x[i], y[i]), T) &amp;&amp; id != i){
                neighbours[id][i] = 1;
            } else {
                neighbours[id][i] = 0;
            }
    }
    lostNeighbours(id);
    nSharedNeighbours(id);
}</declaration>
	<template>
		<name x="5" y="5">Robot</name>
		<parameter>int id</parameter>
		<declaration>// Place local declarations here.
clock x;</declaration>
		<location id="id0" x="-544" y="-340">
			<name x="-612" y="-374">initial</name>
		</location>
		<location id="id1" x="-323" y="-340">
			<name x="-333" y="-374">turn_random</name>
			<committed/>
		</location>
		<location id="id2" x="-323" y="153">
			<name x="-297" y="127">turn_180</name>
			<committed/>
		</location>
		<location id="id3" x="-323" y="-110">
			<name x="-399" y="-135">forward</name>
		</location>
		<location id="id4" x="289" y="-110">
			<name x="297" y="-144">if</name>
			<committed/>
		</location>
		<location id="id5" x="59" y="-341">
			<name x="49" y="-375">else_if</name>
			<committed/>
		</location>
		<location id="id6" x="8" y="-110">
			<name x="-2" y="-144">grid</name>
			<committed/>
		</location>
		<init ref="id0"/>
		<transition id="id7">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="187" y="119">turn180(id)</label>
			<nail x="289" y="153"/>
		</transition>
		<transition id="id8">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="assignment" x="-501" y="-17">reverseDirection(id)</label>
		</transition>
		<transition id="id9">
			<source ref="id6"/>
			<target ref="id2"/>
			<label kind="guard" x="-238" y="35">gridBoundary(id)</label>
			<nail x="8" y="68"/>
			<nail x="-246" y="68"/>
		</transition>
		<transition id="id10">
			<source ref="id6"/>
			<target ref="id4"/>
			<label kind="guard" x="76" y="-144">!gridBoundary(id)</label>
		</transition>
		<transition id="id11">
			<source ref="id3"/>
			<target ref="id6"/>
			<label kind="assignment" x="-238" y="-102">moveForward(id),
updateNeighbours(id),
updateConnections(id),
updateDistances()</label>
		</transition>
		<transition id="id12">
			<source ref="id5"/>
			<target ref="id3"/>
			<label kind="guard" x="-85" y="-255">!turnRandom(id)</label>
			<nail x="59" y="-221"/>
			<nail x="-263" y="-221"/>
		</transition>
		<transition id="id13">
			<source ref="id5"/>
			<target ref="id1"/>
			<label kind="guard" x="-187" y="-374">turnRandom(id)</label>
		</transition>
		<transition id="id14">
			<source ref="id4"/>
			<target ref="id5"/>
			<label kind="guard" x="187" y="-374">!turn180(id)</label>
			<nail x="289" y="-341"/>
		</transition>
		<transition id="id15">
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="select" x="-518" y="-238">dir : int[0,3]</label>
			<label kind="assignment" x="-518" y="-221">mapDirection(id, dir)</label>
		</transition>
		<transition id="id16">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="assignment" x="-518" y="-331">updateNeighbours(id),
updateConnections(id)</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
P0 = Robot(0);
P1 = Robot(1);
P2 = Robot(2);

// List one or more processes to be composed into a system.
system P0, P1, P2;
</system>
	<queries>
		<option key="--diagnostic" value="0"/>
		<query>
			<formula>A[] not deadlock</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-08-21 17:42:39 +0200">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>A[] P0.turn_random imply n_shared_neighbours[0] &lt;= BETA </formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-08-21 17:10:23 +0200">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; n_shared_neighbours[0] != 0</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-08-21 17:16:39 +0200">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; P0.turn_random &amp;&amp; n_shared_neighbours[0] &gt; BETA &amp;&amp; k[0] &gt; old_k[0]</formula>
			<comment>There exists a path for robot P0 where it performs random turn bot only after initial state</comment>
			<result outcome="success" type="quality" timestamp="2024-08-21 17:32:04 +0200">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; P0.turn_180</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-08-21 16:50:18 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A[] forall(i : int[0,R-1]) abs(x[i]) &lt; G &amp;&amp; abs(y[i]) &lt; G</formula>
			<comment>All robots will always stay inside of the grid</comment>
			<result outcome="success" type="quality" timestamp="2024-08-21 17:05:19 +0200">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>A[] P0.turn_random imply ( x[0] == 0 &amp;&amp; y[0] == 0 )</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-08-21 17:08:21 +0200">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>A[] P0.turn_random imply x[0] == 0</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-08-21 17:08:02 +0200">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>A[] P0.turn_random imply P1.forward or P1.initial</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-08-21 17:46:11 +0200">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
	</queries>
</nta>
