<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.

// Number of robots - R, Beta parameter - BETA, Signal threshold - T
const int R = 3;
const int T = 2;
const int BETA = 2;

// Robot coordinates
int x[R];
int y[R];

// List of current and old neighbours lists for each robot
// Convention: 
//    - id of the robot will point to its neighbours list
//    - 1 at position id indicates connection with robot of a given id, 0 otherwise
int neighbours[R][R];
int last_neighbours[R][R];

// Number of connections and old connections for each robot
int k[R];
int last_k[R];

// Updates k and last_k
void updateConnections(int id){
   int i;
   int n;
   last_k[id] = k[id];
   for (i = 0; i &lt; R; i++){
       if (neighbours[id][i] == 1){
           n++;
       }
   }
   k[id] = n;
}

// Returns the number of neighbours shared between two robots
int sharedNeighbours(int id1, int id2){
    int shared;
    int i;
    for (i = 0; i &lt; R; i++){
        if(neighbours[id1][i] == neighbours[id2][i] &amp;&amp; neighbours[id1][i] == 1){
            shared++;
        }
    }
    return shared;
}

// Decide if robot should turn around
bool turnBack(int id1){
    int id2;
    int n_shared;
    for (id2 = 0; id2 &lt; R; id2++){
        if (neighbours[id1][id2] == 1 &amp;&amp; last_neighbours[id1][id2] == 0){
            n_shared += sharedNeighbours(id1, id2);
        }
    }
    if (n_shared &lt;= BETA){
        return true;
    }
    return false;
}

// Calculates Euclidean distance between robots
double distance(int x1, int y1, int x2, int y2){
    return sqrt(pow(abs(x1 - x2), 2) + pow(abs(y1 - y2), 2));
}

// Checks if distance between robots is within a signal threshold
bool connected(double distance, double threshold){
    return distance &lt;= threshold;
}

void updateNeighbours(){
    int id1;
    int id2;
    for (id1 = 0; id1 &lt; R; id1++){
        for (id2 = 0; id2 &lt; id1; id2++){
            if (connected(distance(x[id1], y[id1], x[id2], y[id2]), T)){
                neighbours[id1][id2] = 1;
                neighbours[id2][id1] = 1;
            }
        } 
    }
}</declaration>
	<template>
		<name x="5" y="5">Template</name>
		<declaration>// Place local declarations here.
</declaration>
		<location id="id0" x="0" y="0">
		</location>
		<init ref="id0"/>
	</template>
	<system>// Place template instantiations here.
Process = Template();
// List one or more processes to be composed into a system.
system Process;
</system>
	<queries>
		<query>
			<formula/>
			<comment/>
		</query>
	</queries>
</nta>
