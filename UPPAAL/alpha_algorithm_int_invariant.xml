<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// number of robots - n, signal radius - r
const int n = 3;
const int r = 5;

// x coordinates - X, y coordinates - Y
int X[n];
int Y[n];

// number of neighbours - N, number of last neighbours - L, mutual distance to neighbours - D
int N[n];
int L[n];
int D[n][n];


int x_direction(int direction){
    // maps direction to x axis
    if (direction == 1){
        // right
        return 1;
    }
    if (direction == 3){
        // left
        return -1;
    }
    // neither
    return 0;
}

int y_direction(int direction){
    // maps direction to y axis
    if (direction == 0){
        // up
        return 1;
    }
    if (direction == 2){
        // down
        return -1;
    }
    // neither
    return 0;
}

int reverse(int direction){
    // reverses direction
    return direction * -1;
}

double distance(int x_1, int y_1, int x_2, int y_2){
    // calculates Euclidean distance between points 1 &amp; 2
    int x = abs(x_1 - x_2);
    int y = abs(y_1 - y_2);
    return sqrt(x*x + y*y);
} 

void update_distances(){
    // updates the array that stores distances between robots
    int i, j;
    for (i = 0; i &lt; n; i++){
        for (j = 0; j &lt; n; j++){
            if(i == j){
                D[i][j] = 1000;
            } else {
                D[i][j] = fint(distance(X[i], Y[i], X[j], Y[j]));
            }
            
        }
    }
}

bool connected(double d){
    // returns true if distance between points 1 &amp; 2 is lower or equal to radius r
    return d &lt;= r*1.0;
}

int neighbours(int id){
    // returns number of connections for robot with given id
    int x_1 = X[id];
    int y_1 = Y[id];
    int k = 0;
    int i = 0;
    for (i = 0; i &lt; n; i++){
        double d = distance(x_1, y_1, X[i], Y[i]);
        bool c = connected(d);
        // is robot connected to another robot
        if(i != id &amp;&amp; c){
            // increment neighbour counter
            k++;
        }
    }
    return k;
}

void update_neighbours(){
    // updates the array that stores number of neighbours for each robot
    int i;
    for (i = 0; i &lt; n; i++){
        N[i] = neighbours(i);
    }
}

void update_last(int id){
    L[id] = N[id];
}
</declaration>
	<template>
		<name x="5" y="5">Robot</name>
		<parameter>int id, int x, int y, int x_dir, int y_dir, int alpha</parameter>
		<declaration>// Place local declarations here.
clock c;</declaration>
		<location id="id0" x="-663" y="-348">
			<name x="-748" y="-357">initial</name>
			<label kind="invariant" x="-739" y="-323">c &lt;= 5</label>
		</location>
		<location id="id1" x="-238" y="-348">
			<name x="-248" y="-382">turn_random</name>
			<committed/>
		</location>
		<location id="id2" x="-238" y="255">
			<name x="-323" y="247">turn_180</name>
			<committed/>
		</location>
		<location id="id3" x="144" y="-34">
			<name x="161" y="-59">forward</name>
			<label kind="invariant" x="161" y="-25">c &lt;= 5</label>
		</location>
		<location id="id4" x="646" y="-34">
			<name x="663" y="-51">if</name>
			<committed/>
		</location>
		<location id="id5" x="144" y="-348">
			<name x="153" y="-382">else_if</name>
			<committed/>
		</location>
		<init ref="id0"/>
		<transition id="id6">
			<source ref="id5"/>
			<target ref="id3"/>
			<label kind="guard" x="153" y="-204">!(N[id] &gt; L[id])</label>
		</transition>
		<transition id="id7">
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="select" x="-229" y="-238">direction : int[0, 3]</label>
			<label kind="assignment" x="-229" y="-212">x_dir = x_direction(direction),
y_dir = y_direction(direction)</label>
			<nail x="-238" y="-68"/>
		</transition>
		<transition id="id8">
			<source ref="id5"/>
			<target ref="id1"/>
			<label kind="guard" x="-85" y="-382">N[id] &gt; L[id]</label>
		</transition>
		<transition id="id9">
			<source ref="id4"/>
			<target ref="id5"/>
			<label kind="guard" x="382" y="-382">!(N[id] &lt; L[id] &amp;&amp; N[id] &lt; alpha)</label>
			<nail x="646" y="-348"/>
		</transition>
		<transition id="id10">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="391" y="221">N[id] &lt; L[id] &amp;&amp; N[id] &lt; alpha</label>
			<nail x="646" y="255"/>
		</transition>
		<transition id="id11">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="assignment" x="357" y="-204">c = 0,
x += x_dir,
y += y_dir,
X[id] = x,
Y[id] = y,
update_last(id),
update_distances(),
update_neighbours()</label>
		</transition>
		<transition id="id12">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="assignment" x="-229" y="119">x_dir = reverse(x_dir),
y_dir = reverse(y_dir)</label>
			<nail x="-238" y="17"/>
		</transition>
		<transition id="id13">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="select" x="-620" y="-340">direction : int[0, 3]</label>
			<label kind="assignment" x="-620" y="-314">x_dir = x_direction(direction),
y_dir = y_direction(direction),
update_distances(),
update_neighbours(),
update_last(id),
c = 0</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
// int id, int x, int y, int x_dir, int y_dir, int alpha
P1 = Robot(0, 0, 0, 0, 0, 1);
P2 = Robot(1, 0, 0, 0, 0, 1);
P3 = Robot(2, 0, 0, 0, 0, 1);

// List one or more processes to be composed into a system.
system P1, P2, P3;
</system>
	<queries>
		<option key="--diagnostic" value="1"/>
		<query>
			<formula>E&lt;&gt; P1.turn_random &amp;&amp; P1.x != 0</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-07-22 10:59:06 +0200">
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A[] P1.c &lt;= 5</formula>
			<comment/>
		</query>
	</queries>
</nta>
