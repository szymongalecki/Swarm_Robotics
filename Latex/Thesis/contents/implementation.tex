\section{Implementation}
In this section, we will describe the implementation of the timed automaton model from the previous section, shown in Figure \ref{fig:automaton}. Our tool of choice is UPPAAL, an integrated solution for modeling, simulation, and verification of timed automata. We will present the implementation details and limitations imposed on the model in the following subsection.  Model variables representing its state will be described along with the most important functions.


\subsection{Model}
The implementation of the timed automaton, shown in Figure \ref{fig:implementation}, includes an additional state called \texttt{grid}, which is not present in the automaton depicted in Figure \ref{fig:automaton}. Global functions of the implementation abstract away the underlying complexity. The  \texttt{grid} state is a consequence of imposing limitations on the environment size defined in the previous section. This allows us to reduce the state space size and perform verification. It is the biggest change made to the original algorithm, defined in Figure \ref{fig:pseudocode}. In that state, it is determined whether a robot has reached the boundary of the grid. If yes, the robot will transition to the state \texttt{turn\_180} and change its direction by 180 degrees as it cannot continue moving forward outside of its environment. If a robot has not reached the boundary of its environment it will transition to the \texttt{if} state where it will transition to further states based on the original rules of the algorithm.

\begin{figure}[H]
\caption{Asynchronous implementation of the Beta algorithm}
\includegraphics[width=\textwidth]{images/implementation_asynchronous.png}
\label{fig:implementation}
\end{figure}

\noindent
The implementation of the Beta algorithm presented in Figure \ref{fig:implementation} is asynchronous as stated by the author of the algorithm. Robots can move at different pace and time, independent of each other. We also implemented a synchronized version of the Beta algorithm to investigate the influence of the concurrency mode on verification results. The synchronized implementation is presented in Figure \ref{fig:implementation_synchronised}, and its synchronization mechanism in Figure \ref{fig:implementation_synchronised_barrier}. The synchronized version enforces that all robots move at the same time. The synchronization mechanism, which we will call barrier, has a variable \texttt{n} initialized to the number of robots in the swarm. Each time a robot transitions to the \texttt{forward} state it will use a synchronization channel \texttt{done} to notify the barrier. The barrier will decrement its variable \texttt{n} upon receiving a signal from a robot. When the value of \texttt{n} reaches 0, all robots will be blocked in the \texttt{forward} state. The barrier then will send a signal using synchronization channel \texttt{step} and reset the value of the variable \texttt{n} to the number of robots in the swarm. Robots waiting in the \texttt{forward} state will receive this signal from the \texttt{step} channel and transition to \texttt{grid} state at the same time. They will then progress to the \texttt{forward} state in the random order, possibly changing its direction. The order in which they reach the \texttt{forward} state does not influence swarm behavior. A robot decides whether to change direction based on the state of the swarm. The state of the swarm, most importantly robot positions, will not change until the next collective step forward. In other words, the direction of the robot is not a variable that influences the behavior of another robot, unlike its position. 

\begin{figure}[H]
\caption{Synchronised implementation of the Beta algorithm}
\includegraphics[width=\textwidth]{images/implementation_synchronised.png}
\label{fig:implementation_synchronised}
\end{figure}

\begin{figure}[H]
\caption{Synchronisation mechanism}
\centering
\includegraphics[width=0.5\textwidth]{images/implementation_synchronised_barrier.png}
\label{fig:implementation_synchronised_barrier}
\end{figure}



\subsection{System variables}
Presented below variables fully specify the robot swarm in both asynchronous and synchronised version. Implemented functionality depends on those variables and verified properties are only valid in relation to its values.\\
\texttt{N} - number of robots in a swarm;\\
\texttt{R} - radius of the signal used for connection;\\
\texttt{STEP} - step size of a robot;\\
\texttt{BETA} - beta parameter of the algorithm;\\
\texttt{G} - grid boundary, resulting area of the grid = 2\texttt{G} x 2\texttt{G};\\\\
Asynchronous implementation variables:\\
\texttt{T\_MAX} - time threshold for state invariant;\\
\texttt{C} - global clock for the system;



\subsection{Movement}
Before explaining the functions that control the movement and direction of the robot, we will first introduce the data structures used by these functions.
\\\\
\texttt{x[N]} - list of x-axis coordinates for each robot;\\
\texttt{y[N]} - list of y-axis coordinates for each robot;\\
\texttt{x\_dir[N]} - list of x-axis directions for each robot;\\
\texttt{y\_dir[N]} - list of y-axis directions for each robot;\\
\\
\noindent
Four global functions govern the movement of the robot, namely, \texttt{mapDirection}, \texttt{reverseDirection}, \texttt{moveForward}, \texttt{gridBoundary}. The \texttt{mapDirection} function is triggered upon transition from state \texttt{turn\_random} to state \texttt{forward} and provided with \texttt{id} of the robot and randomly drawn integer \texttt{dir} that will be mapped to one of four directions. The \texttt{reverseDirection} function is triggered upon transition from state \texttt{turn\_180} to state \texttt{forward} and provided with \texttt{id} of the robot whose direction is to be reversed. The \texttt{moveForward} function is triggered upon transition from state \texttt{forward} to state \texttt{grid} and provided with \texttt{id} of the robot that is to be moved forward. The \texttt{gridBoundary} function is used as a transition guard for states \texttt{if} and \texttt{turn\_180}. It takes \texttt{id} of the robot as a parameter. If a robot reaches or crosses the grid boundary it will transition from state \texttt{grid} to state \texttt{turn\_180} and turn 180 degrees to stay within the grid boundary. If a robot has not reached the grid boundary it will transition to the \texttt{if} state and move according to the original specification of the algorithm. The implementation of those functions is shown in Figure \ref{fig:movement_implementation}.


\begin{figure}[H]
\caption{Implementation of functions controlling robot movement}
\begin{lstlisting}[style=code]
void mapDirection(int id, int dir){
    if (dir == 0){
		// up
        x_dir[id] = 0;
        y_dir[id] = 1;
    }
    if (dir == 1){
		// right
        x_dir[id] = 1;
        y_dir[id] = 0;
    }
    if (dir == 2){
		// down
        x_dir[id] = 0;
        y_dir[id] = -1;
    }
    if (dir == 3){
		// left
        x_dir[id] = -1;
        y_dir[id] = 0;
    }
}


void reverseDirection(int id){
	x_dir[id] *= -1;
	y_dir[id] *= -1;
}


void moveForward(int id){
	x[id] += x_dir[id] * STEP;
	y[id] += y_dir[id] * STEP;
}


bool gridBoundary(int id){
    return abs(x[id]) >= G || abs(y[id]) >= G;
}
\end{lstlisting}
\label{fig:movement_implementation}
\end{figure}
\newpage

\subsection{Connection}
The connection part of the implementation focuses on two key tasks: simulating the physical signal real robots would use to detect their neighbors and providing the functionality and data structures needed for the robots to act on this connection information. A robot will detect its neighbor if the Euclidean distance between them is smaller than signal radius \texttt{R}. Data structures crucial for both of those tasks are listed below. Two-dimensional lists are adjacency matrices where an entry 1 indicates a connection between two robots and 0 indicates the absence of one. \\\\
\texttt{neighbours[N][N]} - list of neighbours for each robot;\\
\texttt{last\_neighbours[N][N]} - list of previous neighbours for each robot;\\ 
\texttt{lost\_neighbours[N][N]} - list of lost neighbours for each robot;\\
\texttt{shared\_neighbours[N][N]} - list of shared neighbours with the lost neighbours;\\
\texttt{shared[N]} - number of shared neighbours with the lost neighbours;\\
\texttt{k[N]} - number of connections for each robot;\\
\texttt{last\_k[N]} - number of last connections for each robot;\\
