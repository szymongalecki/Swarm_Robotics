\section{Implementation}
In this section, we will describe the implementation of the timed automaton model from the previous section, shown in Figure \ref{fig:automaton}. Our tool of choice is UPPAAL, an integrated solution for modeling, simulation, and verification of timed automata. We will present the implementation of limitations imposed on the model in the following subsection.  Model variables representing its state will be described along with the most important functions.


\subsection{Model}
Implementation of the timed automaton, shown in Figure \ref{fig:implementation}, has an additional state called \texttt{grid} and global functions that abstract away the underneath complexity. This state is a consequence of imposing limitations on the environment size defined in the previous section. This allows us to reduce the state space size and perform verification. It is the biggest change made to the original algorithm, defined in Figure \ref{fig:pseudocode}. In that state, it is determined whether a robot has reached the boundary of the grid. If yes, the robot will transition to the state \texttt{turn\_180} and change its direction by 180 degrees as it cannot continue moving forward outside of its environment. If a robot has not reached the boundary of its environment it will transition to the \texttt{if} state where it will follow the original rules of the algorithm.

\begin{figure}[H]
\caption{Asynchronous implementation of the Beta algorithm}
\includegraphics[width=\textwidth]{images/implementation.png}
\label{fig:implementation}
\end{figure}

\noindent
The implementation of the Beta algorithm presented in Figure \ref{fig:implementation} is asynchronous as stated by the author of the algorithm. Robots can move at different pace and time, independent of each other. We also implemented a synchronized version of the Beta algorithm to investigate the influence of the concurrency mode on verification results. The synchronized implementation is presented in Figure \ref{fig:implementation_synchronised}, and its synchronization mechanism in Figure \ref{fig:implementation_synchronised_barrier}. The synchronized version enforces that all robots move at the same time. The synchronization mechanism, which we will call barrier, has a variable \texttt{n} initialized to the number of robots in the swarm. Each time a robot transitions to the \texttt{forward} state it will use a synchronization channel \texttt{done} to notify the barrier. The barrier will decrement its variable \texttt{n} upon receiving a signal from a robot. When the value of \texttt{n} reaches 0, all robots will be blocked in the \texttt{forward} state. The barrier then will send a signal using synchronization channel \texttt{step} and reset the value of the variable \texttt{n} to the number of robots in the swarm. Robots waiting in the \texttt{forward} state will receive this signal from the \texttt{step} channel and transition to \texttt{grid} state at the same time. They will then progress to the \texttt{forward} state in the random order, possibly changing its direction. The order in which they reach the \texttt{forward} state does not influence swarm behavior. A robot decides whether to change direction based on the state of the swarm. The state of the swarm, most importantly robot positions, will not change until the next collective step forward. In other words, the direction of the robot is not a variable that influences the behavior of another robot, unlike its position. 

\begin{figure}[H]
\caption{Synchronised implementation of the Beta algorithm}
\includegraphics[width=\textwidth]{images/implementation_synchronised.png}
\label{fig:implementation_synchronised}
\end{figure}

\begin{figure}[H]
\caption{Synchronisation mechanism}
\centering
\includegraphics[width=0.5\textwidth]{images/implementation_synchronised_barrier.png}
\label{fig:implementation_synchronised_barrier}
\end{figure}

\subsection{Movement}



\subsection{Connection}



\subsection{System variables}
